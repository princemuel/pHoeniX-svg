---
import { execSync } from "node:child_process";
import { join } from "node:path";
import { getCollection, getEntry, render } from "astro:content";
import { OCTOKIT_USERNAME } from "astro:env/server";
import Markdown from "@/components/atoms/markdown.astro";
import { log_in_dev } from "@/helpers/log-in-dev";
import { withBaseUrl } from "@/helpers/with-base-url";
import RootLayout from "@/layouts/root.astro";
import { blog_ld, profile_ld } from "@/lib/jsonld";
import { remove_key } from "@/utilities/objects";

import type { GetStaticPaths, InferGetStaticPropsType } from "astro";
import type {
  Article,
  BreadcrumbList,
  Graph,
  ImageObject,
  WebPage,
  WithContext,
} from "schema-dts";

export const getStaticPaths = (async () => {
  const entries = await getCollection(
    "posts",
    ({ data }) => !(import.meta.env.PROD && data.draft),
  );

  return entries.map((entry) => ({
    props: { entry },
    params: { slug: entry.id },
  }));
}) satisfies GetStaticPaths;

type Props = InferGetStaticPropsType<typeof getStaticPaths>;

const { entry } = Astro.props;

const [markdown, author] = await Promise.all([render(entry), getEntry(entry.data.author)]);

const { Content, remarkPluginFrontmatter } = markdown;

// update the collection schema with plugin data
entry.data.updatedAt = new Date(remarkPluginFrontmatter.updatedAt);
entry.data.duration = remarkPluginFrontmatter.duration;
entry.data.words = remarkPluginFrontmatter.words;

console.log(remarkPluginFrontmatter);
const article_ld = {
  "@context": "https://schema.org",
  "@type": "Article",
  "@id": withBaseUrl(`/blog/${entry.id}#article`).toString(),
  isPartOf: { "@id": withBaseUrl(`/blog/${entry.id}`).toString() },
  author: {
    name: author?.data?.name,
    "@id": withBaseUrl("/about-me").toString(),
  },
  headline: entry.data.title,
  description: entry.data.description,
  datePublished: entry.data.publishedAt.toISOString(),
  dateModified: entry.data.updatedAt.toISOString(),
  mainEntityOfPage: { "@id": withBaseUrl(`/blog/${entry.id}`).toString() },
  wordCount: remarkPluginFrontmatter.words,
  commentCount: 0,
  publisher: { "@id": withBaseUrl("/about-me").toString() },
  image: { "@id": withBaseUrl(`/blog/${entry.id}/og.png`).toString() },
  thumbnailUrl: withBaseUrl(`/blog/${entry.id}/og.png`).toString(),
  keywords: entry.data.tags,
  inLanguage: "en-US",
  potentialAction: [
    {
      "@type": "CommentAction",
      name: "Comment",
      target: [withBaseUrl(`/blog/${entry.id}/#respond`).toString()],
    },
  ],
  copyrightYear: entry.data.publishedAt.getFullYear(),
  copyrightHolder: { "@id": withBaseUrl("/about-me").toString() },
  accessibilityFeature: ["tableOfContents"],
} satisfies WithContext<Article>;

const page_ld = {
  "@context": "https://schema.org",
  "@type": "WebPage",
  "@id": withBaseUrl(`/blog/${entry.id}`).toString(),
  url: withBaseUrl(`/blog/${entry.id}`).toString(),
  name: entry.data.title,
  description: entry.data.description,
  isPartOf: { "@id": withBaseUrl(`/blog/${entry.id}`).toString() },
  primaryImageOfPage: {
    "@id": withBaseUrl(`/blog/${entry.id}/og.png`).toString(),
  },
  image: { "@id": withBaseUrl(`/blog/${entry.id}/og.png`).toString() },
  thumbnailUrl: withBaseUrl(`/blog/${entry.id}/og.png`).toString(),
  datePublished: entry.data.publishedAt.toISOString(),
  dateModified: entry.data.updatedAt.toISOString(),
  breadcrumb: {
    "@id": withBaseUrl(`/blog/${entry.id}#breadcrumb`).toString(),
  },
  inLanguage: "en-US",
  potentialAction: [
    {
      "@type": "ReadAction",
      target: [withBaseUrl(`/blog/${entry.id}`).toString()],
    },
  ],
} satisfies WithContext<WebPage>;

const image_ld = {
  "@context": "https://schema.org",
  "@type": "ImageObject",
  "@id": withBaseUrl(`/blog/${entry.id}/og.png`).toString(),
  url: withBaseUrl(`/blog/${entry.id}/og.png`).toString(),
  width: "1200",
  height: "630",
} satisfies WithContext<ImageObject>;

const breadcrumb_ld = {
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "@id": withBaseUrl(`/blog/${entry.id}#breadcrumb`).toString(),
  itemListElement: [
    {
      "@type": "ListItem",
      position: 1,
      name: "Prince Muel - Frontend Engineer, Educator, Musician",
      item: withBaseUrl("/").toString(),
    },
    {
      "@type": "ListItem",
      position: 2,
      name: "Blog",
      item: withBaseUrl("/blog").toString(),
    },
    {
      "@type": "ListItem",
      position: 3,
      name: entry.data.title,
      item: withBaseUrl(`/blog/${entry.id}`).toString(),
    },
  ],
} as WithContext<BreadcrumbList>;

const jsonld = {
  "@context": "https://schema.org",
  "@graph": remove_key("@context", [
    article_ld,
    page_ld,
    image_ld,
    breadcrumb_ld,
    blog_ld,
    profile_ld,
  ]),
} satisfies Graph;

const { title, description, tags, permalink, publishedAt, updatedAt } = entry.data;

const github_links = (() => {
  try {
    const [username = "", repo = "", branch = "", file_name = ""] = [
      OCTOKIT_USERNAME,
      execSync("basename -s .git `git config --get remote.origin.url`"),
      execSync("git rev-parse --abbrev-ref HEAD"),
      (Content.moduleId ?? "").split("/app")[1] ?? "",
    ].map((value) => value.toString().trim());

    const searchParams = new URLSearchParams({
      labels: "Status: Needs Triage",
      template: "suggestion.yml",
      title: `${title}: <Short description of your suggestion>`,
      "resource-url": Astro.url.href,
    });

    const github_link = `https://github.com/${username}/${repo}`;
    const github_path = join("app", file_name);

    const github_edit_url = `${github_link}/edit/${branch}/${github_path}`;
    const github_commits_url = `${github_link}/commits/${branch}/${github_path}`;

    const issues_url = `${github_link}/issues/new`;
    const github_report_url = new URL(issues_url);
    github_report_url.search = searchParams.toString();

    return [
      { text: "Improve on github", url: github_edit_url },
      { text: "Report an issue", url: github_report_url.toString() },
      { text: "See post changelog", url: github_commits_url },
    ];
  } catch (error) {
    log_in_dev(error);
    return [];
  }
})();

Astro.response.headers.set("netlify-cache-tag", entry.id);
---

<RootLayout title={[""]} description="">
  <script
    is:inline
    type="application/ld+json"
    slot="jsonld"
    set:html={JSON.stringify(jsonld)}
  />
  <Markdown>
    <h1 id="headline">{entry.data.title}</h1>
    <Content />
  </Markdown>
</RootLayout>
